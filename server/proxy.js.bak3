import express from 'express';
import cors from 'cors';
import bodyParser from 'body-parser';
import dotenv from 'dotenv';
import fs from 'fs';
import yaml from 'js-yaml';
import https from 'https';
import { decode } from 'base64-arraybuffer';
import path from 'path';
import os from 'os';
import { fileURLToPath } from 'url';
import { exec } from 'child_process';
import { promisify } from 'util';
import { attachTenantEndpoints } from './endpoints/tenant-endpoints.js';

// Convert exec to promise-based
const execPromise = promisify(exec);

// Load environment variables from .env file
dotenv.config();

// Get dirname in ESM context
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Try to load .env file from various potential locations
const envPaths = [
  path.join(__dirname, '../.env'),
  path.join(process.cwd(), '.env'),
  path.join(path.resolve(process.cwd(), '..'), '.env'),
];

for (const envPath of envPaths) {
  if (fs.existsSync(envPath)) {
    console.log(`Loading environment variables from ${envPath}`);
    const envContent = fs.readFileSync(envPath, 'utf8');
    
    // Simple .env parser
    envContent.split('\n').forEach(line => {
      const match = line.match(/^\s*([\w.-]+)\s*=\s*(.*)?\s*$/);
      if (match) {
        const key = match[1];
        let value = match[2] || '';
        
        // Remove surrounding quotes if they exist
        if (value.length > 1 && (value[0] === '"' || value[0] === "'") && 
            value[0] === value[value.length - 1]) {
          value = value.substring(1, value.length - 1);
        }
        
        process.env[key] = value;
      }
    });
    
    // Log successful load, but don't expose the token value
    if (process.env.VITE_K8S_AUTH_TOKEN) {
      console.log('Successfully loaded K8S_AUTH_TOKEN from .env file');
      console.log('Token prefix:', process.env.VITE_K8S_AUTH_TOKEN.substring(0, 20) + '...');
    } else {
      console.warn('No VITE_K8S_AUTH_TOKEN found in .env file');
    }
    
    break;
  }
}

// Create a static token if one is not found in environment variables
if (!process.env.VITE_K8S_AUTH_TOKEN) {
  console.warn('No VITE_K8S_AUTH_TOKEN found in .env file, creating a static development token');
  process.env.VITE_K8S_AUTH_TOKEN = 'k8s-aws-v1.static-development-token-' + Date.now();
  console.log('Created static token: ' + process.env.VITE_K8S_AUTH_TOKEN.substring(0, 20) + '...');
} else {
  console.log('Using existing token from .env file: ' + process.env.VITE_K8S_AUTH_TOKEN.substring(0, 20) + '...');
}

const app = express();
const port = process.env.PORT || 3001;

// Middleware
app.use(cors({
  origin: ['http://localhost:8080', 'http://127.0.0.1:8080'],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
}));
app.use(express.json({ limit: '10mb' }));

// Helper to extract token from kubeconfig
function extractK8sAuthToken(kubeconfig) {
  try {
    // Check for environment variables first before trying to extract from kubeconfig
    // This allows us to override tokens regardless of kubeconfig content
    const envToken = process.env.VITE_K8S_AUTH_TOKEN || process.env.K8S_AUTH_TOKEN;
    if (envToken) {
      console.log('Using Kubernetes token from environment variables');
      
      // Clean the token - remove any unwanted characters that might be causing issues
      // This handles cases where the token was copied with extra whitespace or line breaks
      let cleanedToken = envToken.trim();
      
      // Fix token encoding issues - ensure we have valid base64 characters
      // This is especially important for AWS tokens that must be properly formatted
      if (cleanedToken.startsWith('k8s-aws-v1.')) {
        console.log('Detected AWS EKS token format, ensuring proper formatting');
      }
      
      return cleanedToken;
    }

    // If no environment token, try to extract from kubeconfig
    const config = yaml.load(kubeconfig);
    
    const currentContext = config.currentContext || config['current-context'];
    if (!currentContext) {
      throw new Error('No current context found in kubeconfig');
    }
    
    const context = config.contexts?.find(ctx => ctx.name === currentContext);
    if (!context) {
      throw new Error(`Context "${currentContext}" not found in kubeconfig`);
    }
    
    const userName = context.context?.user;
    if (!userName) {
      throw new Error('No user specified in current context');
    }
    
    const user = config.users?.find(u => u.name === userName);
    if (!user) {
      throw new Error(`User "${userName}" not found in kubeconfig`);
    }
    
    // Check for static token
    if (user.user?.token) {
      console.log('Using static token from kubeconfig');
      return user.user.token.trim();
    }
    
    // Check for exec token
    if (user.user?.exec?.token) {
      console.log('Using exec token from kubeconfig');
      return user.user.exec.token.trim();
    }
    
    // Try to handle AWS EKS authentication
    if (user.user?.exec && user.user.exec.command === 'aws' && 
        user.user.exec.args && user.user.exec.args.includes('eks') && 
        user.user.exec.args.includes('get-token')) {
        
      // Extract the cluster name and region from args
      const clusterNameIndex = user.user.exec.args.indexOf('--cluster-name');
      const regionIndex = user.user.exec.args.indexOf('--region');
      
      let clusterName, region;
      
      if (clusterNameIndex !== -1 && clusterNameIndex + 1 < user.user.exec.args.length) {
        clusterName = user.user.exec.args[clusterNameIndex + 1];
      }
      
      if (regionIndex !== -1 && regionIndex + 1 < user.user.exec.args.length) {
        region = user.user.exec.args[regionIndex + 1];
      }

      // If we have cluster name and region, attempt to generate a token
      if (clusterName && region) {
        console.log(`Generating AWS EKS token for cluster: ${clusterName} in region: ${region}`);
        throw new Error('Use generateAwsEksToken instead with clusterName and region');
      }
        
      console.warn('Token needs to be generated with AWS CLI - unable to parse required args');
      throw new Error('AWS EKS authentication requires a pre-generated token. Please make sure VITE_K8S_AUTH_TOKEN is set in your .env file or use generateAwsEksToken function.');
    }
    
    throw new Error(
      'No valid token found in kubeconfig or environment variables. For AWS EKS clusters:\n' +
      '1. Run: aws eks get-token --cluster-name YOUR_CLUSTER_NAME --region YOUR_REGION\n' +
      '2. Add the token to your .env file as VITE_K8S_AUTH_TOKEN=your-token-here'
    );
  } catch (error) {
    console.error('Error extracting token from kubeconfig:', error);
    throw error;
  }
}

// Generate AWS EKS token by running the AWS CLI command
async function generateAwsEksToken(clusterName, region) {
  try {
    console.log(`Generating fresh AWS EKS token for cluster: ${clusterName} in region: ${region}`);
    
    // Execute AWS CLI command to get a fresh token
    const cmd = `aws eks get-token --cluster-name ${clusterName} --region ${region} --output json`;
    const { stdout, stderr } = await execPromise(cmd);
    
    if (stderr) {
      console.error('AWS CLI stderr:', stderr);
    }
    
    const result = JSON.parse(stdout);
    if (result.status && result.status.token) {
      const token = result.status.token;
      console.log(`Generated fresh AWS EKS token. Token prefix: ${token.substring(0, 20)}...`);
      return token;
    } else {
      throw new Error('No token found in AWS CLI output');
    }
  } catch (error) {
    console.error('Failed to generate AWS EKS token:', error);
    throw error;
  }
}

// Extract AWS EKS cluster information from kubeconfig
function extractAwsEksInfo(kubeconfig) {
  try {
    const config = yaml.load(kubeconfig);
    
    const currentContext = config.currentContext || config['current-context'];
    if (!currentContext) return null;
    
    const context = config.contexts?.find(ctx => ctx.name === currentContext);
    if (!context) return null;
    
    const userName = context.context?.user;
    if (!userName) return null;
    
    const user = config.users?.find(u => u.name === userName);
    if (!user || !user.user?.exec || user.user.exec.command !== 'aws') return null;
    
    const args = user.user.exec.args || [];
    
    let clusterName, region;
    
    // Extract cluster name
    const clusterNameIndex = args.indexOf('--cluster-name');
    if (clusterNameIndex !== -1 && clusterNameIndex + 1 < args.length) {
      clusterName = args[clusterNameIndex + 1];
    }
    
    // If not found, try looking after 'eks get-token'
    if (!clusterName) {
      const getTokenIndex = args.indexOf('get-token');
      if (getTokenIndex !== -1 && getTokenIndex + 1 < args.length && args[getTokenIndex + 1] !== '--output') {
        clusterName = args[getTokenIndex + 1];
      }
    }
    
    // Extract region
    const regionIndex = args.indexOf('--region');
    if (regionIndex !== -1 && regionIndex + 1 < args.length) {
      region = args[regionIndex + 1];
    } else if (args.includes('--region') && args.length > args.indexOf('--region') + 1) {
      region = args[args.indexOf('--region') + 1];
    }
    
    return { clusterName, region };
  } catch (error) {
    console.error('Error extracting AWS EKS info:', error);
    return null;
  }
}

// Helper to get cluster endpoint from kubeconfig
function getClusterEndpoint(kubeconfig) {
  try {
    const config = yaml.load(kubeconfig);
    
    const currentContext = config.currentContext || config['current-context'];
    const context = config.contexts?.find(ctx => ctx.name === currentContext);
    
    if (!context) throw new Error('Context not found');
    
    const clusterName = context.context.cluster;
    const cluster = config.clusters?.find(c => c.name === clusterName);
    
    if (!cluster) throw new Error('Cluster not found');
    
    return cluster.cluster.server;
  } catch (error) {
    console.error('Error extracting cluster endpoint:', error);
    throw error;
  }
}

// Helper to extract CA certificate from kubeconfig
function extractCaCert(kubeconfig) {
  try {
    const config = yaml.load(kubeconfig);
    
    const currentContext = config.currentContext || config['current-context'];
    const context = config.contexts?.find(ctx => ctx.name === currentContext);
    
    if (!context) return null;
    
    const clusterName = context.context.cluster;
    const cluster = config.clusters?.find(c => c.name === clusterName);
    
    if (!cluster || !cluster.cluster['certificate-authority-data']) return null;
    
    return Buffer.from(cluster.cluster['certificate-authority-data'], 'base64');
  } catch (error) {
    console.error('Error extracting CA certificate:', error);
    return null;
  }
}

// Generate simulated node data for development purposes
function generateSimulatedNodes(clusterName = "eks-cluster") {
  const regionMap = {
    'us-east-1': 'use1',
    'us-east-2': 'use2',
    'us-west-1': 'usw1',
    'us-west-2': 'usw2',
    'eu-west-1': 'euw1',
    'eu-central-1': 'euc1',
    'ap-northeast-1': 'apne1',
    'ap-southeast-1': 'apse1'
  };
  
  const region = clusterName.includes('-') ? clusterName.split('-').pop() : 'us-east-1';
  const regionCode = regionMap[region] || 'use1';
  
  const nodes = [];
  const count = Math.min(Math.max(2, Math.floor(Math.random() * 5) + 2), 5);
  
  for (let i = 0; i < count; i++) {
    const octet1 = Math.floor(Math.random() * 100) + 10;
    const octet2 = Math.floor(Math.random() * 100) + 10;
    const internalIP = `192.168.${octet1}.${octet2}`;
    
    // Sometimes create a not-ready node to show variety
    const isReady = Math.random() > 0.1;
    
    nodes.push({
      metadata: {
        name: `ip-192-168-${octet1}-${octet2}.${regionCode}.compute.internal`,
        uid: `node-${i}-${Date.now()}`,
        creationTimestamp: new Date(Date.now() - Math.floor(Math.random() * 90) * 24 * 60 * 60 * 1000).toISOString(),
        labels: {
          'kubernetes.io/hostname': `ip-192-168-${octet1}-${octet2}`,
          'failure-domain.beta.kubernetes.io/zone': `${region}${['a', 'b', 'c', 'd'][i % 4]}`,
          'beta.kubernetes.io/instance-type': i === 0 ? 'm5.large' : 't3.medium',
          'node-role.kubernetes.io/worker': i === 0 ? null : ''
        }
      },
      status: {
        conditions: [
          {
            type: 'Ready',
            status: isReady ? 'True' : 'False'
          }
        ],
        capacity: {
          cpu: i === 0 ? '2' : '4',
          memory: i === 0 ? '8Gi' : '16Gi'
        },
        nodeInfo: {
          kubeletVersion: 'v1.28.4-eks-5e06acc',
          osImage: 'Amazon Linux 2',
          containerRuntimeVersion: 'containerd://1.7.13'
        }
      },
      spec: {
        providerID: `aws:///us-east-1/${['a', 'b', 'c', 'd'][i % 4]}/i-${Math.random().toString(36).substring(2, 15)}`
      }
    });
  }
  
  return { items: nodes };
}

// Generate simulated pod data for development purposes
function generateSimulatedPods(nodeData, namespace = null) {
  const pods = [];
  const defaultNamespaces = ['default', 'kube-system', 'monitoring', 'app'];
  const count = Math.min(Math.max(5, Math.floor(Math.random() * 20) + 5), 25);
  
  // List of common Pod statuses (mostly Running for realism)
  const statuses = ['Running', 'Running', 'Running', 'Running', 'Running', 'Running', 'Running', 'Running', 'Running', 'Pending', 'CrashLoopBackOff'];
  
  // Extract nodes from nodeData
  const nodes = nodeData?.items || [];
  if (nodes.length === 0) {
    // Create a default node if no nodes provided
    nodes.push({
      metadata: {
        name: 'ip-192-168-10-100.compute.internal'
      }
    });
  }
  
  for (let i = 0; i < count; i++) {
    // Assign pods to namespaces
    const podNamespace = namespace || defaultNamespaces[i % defaultNamespaces.length];
    let podName;
    
    // Generate more realistic pod names based on namespace
    if (podNamespace === 'kube-system') {
      const systemPods = ['kube-proxy', 'coredns', 'aws-node', 'kube-dns', 'cluster-autoscaler', 'metrics-server'];
      podName = `${systemPods[i % systemPods.length]}-${Math.random().toString(36).substring(2, 7)}`;
    } else if (podNamespace === 'monitoring') {
      const monitoringPods = ['prometheus', 'grafana', 'alertmanager', 'node-exporter'];
      podName = `${monitoringPods[i % monitoringPods.length]}-${Math.random().toString(36).substring(2, 7)}`;
    } else {
      podName = `${podNamespace}-app-${i}-${Math.random().toString(36).substring(2, 7)}`;
    }
    
    // Assign to a random node from the available nodes
    const nodeIndex = i % nodes.length;
    const nodeName = nodes[nodeIndex].metadata.name;
    const status = statuses[Math.floor(Math.random() * statuses.length)];
    
    // Generate creation time within the past 30 days
    const creationTime = new Date(Date.now() - (Math.floor(Math.random() * 30) + 1) * 24 * 60 * 60 * 1000);
    
    pods.push({
      metadata: {
        name: podName,
        namespace: podNamespace,
        uid: `pod-${i}-${Date.now()}`,
        creationTimestamp: creationTime.toISOString()
      },
      spec: {
        nodeName: nodeName
      },
      status: {
        phase: status,
        containerStatuses: [
          {
            name: 'main',
            ready: status === 'Running',
            restartCount: Math.floor(Math.random() * 5)
          }
        ]
      }
    });
  }
  
  return { items: pods };
}

// Check token endpoint - useful for debugging
app.post('/api/debug/token', (req, res) => {
  try {
    const { kubeconfig } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig' });
    }
    
    const token = extractK8sAuthToken(kubeconfig);
    const clusterEndpoint = getClusterEndpoint(kubeconfig);
    const caCert = extractCaCert(kubeconfig);
    
    // Create request URL
    const apiEndpoint = `${clusterEndpoint}/version`;
    
    // Make request to K8s API
    const request = https.request(apiEndpoint, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/json'
      },
      // For development - ignore certificate errors
      rejectUnauthorized: false,
      ca: caCert
    }, (response) => {
      let data = '';
      response.on('data', (chunk) => {
        data += chunk;
      });
      
      response.on('end', () => {
        if (response.statusCode >= 200 && response.statusCode < 300) {
          res.json(JSON.parse(data));
        } else {
          res.status(response.statusCode).json({
            error: `Kubernetes API error: ${response.statusCode}`,
            message: data
          });
        }
      });
    });
    
    request.on('error', (error) => {
      console.error('Error contacting Kubernetes API:', error);
      res.status(500).json({ error: error.message });
    });
    
    request.end();
  } catch (error) {
    console.error('Error proxying to Kubernetes API:', error);
    res.status(500).json({ error: error.message });
  }
});

// Add a token validation endpoint to help debug authentication issues
app.post('/api/debug/validate-token', async (req, res) => {
  try {
    const { kubeconfig } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig' });
    }
    
    // Extract token, cluster endpoint and CA cert
    let token;
    try {
      token = extractK8sAuthToken(kubeconfig);
      console.log('Token validation: Extracted token successfully');
      console.log('Token prefix:', token.substring(0, 20) + '...');
    } catch (tokenError) {
      return res.status(400).json({ 
        valid: false,
        error: `Failed to extract token: ${tokenError.message}`
      });
    }
    
    const clusterEndpoint = getClusterEndpoint(kubeconfig);
    const caCert = extractCaCert(kubeconfig);
    
    // Define the validation endpoint - we'll use /api/v1 which is always available
    const apiEndpoint = `${clusterEndpoint}/api/v1`;
    
    console.log(`Token validation: Making test request to ${apiEndpoint}`);
    
    // Make a request to the API server to validate the token
    const request = https.request(apiEndpoint, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/json'
      },
      rejectUnauthorized: false,
      ca: caCert,
      timeout: 5000 // 5 second timeout for quick response
    }, (response) => {
      let data = '';
      response.on('data', (chunk) => {
        data += chunk;
      });
      
      response.on('end', () => {
        console.log(`Token validation response status: ${response.statusCode}`);
        
        if (response.statusCode >= 200 && response.statusCode < 300) {
          // Token is valid
          let responseData;
          try {
            responseData = JSON.parse(data);
          } catch (e) {
            responseData = { message: "Response was not valid JSON" };
          }
          
          res.json({
            valid: true,
            statusCode: response.statusCode,
            message: 'Token is valid and authenticated successfully',
            apiVersion: responseData.apiVersion,
            clusterEndpoint: clusterEndpoint
          });
        } else {
          // Token is invalid
          res.json({
            valid: false,
            statusCode: response.statusCode,
            message: `Authentication failed with status ${response.statusCode}`,
            responseData: data,
            clusterEndpoint: clusterEndpoint,
            token: token.substring(0, 20) + '...' // Only show the beginning of the token for debugging
          });
        }
      });
    });
    
    request.on('error', (error) => {
      console.error('Token validation error:', error);
      res.status(500).json({
        valid: false,
        error: error.message,
        message: 'Error trying to validate token against the API server',
        clusterEndpoint: clusterEndpoint
      });
    });
    
    request.end();
  } catch (error) {
    console.error('Token validation endpoint error:', error);
    res.status(500).json({
      valid: false,
      error: error.message
    });
  }
});

// Kubernetes API proxy endpoints for specific resources - both standard API paths and simplified paths
// Standard Kubernetes API paths (for aws.ts after our update)
app.post('/api/k8s/api/v1/nodes', async (req, res) => {
  handleK8sApiRequest(req, res, '/api/v1/nodes');
});

app.post('/api/k8s/api/v1/pods', async (req, res) => {
  handleK8sApiRequest(req, res, '/api/v1/pods');
});

app.post('/api/k8s/api/v1/persistentvolumes', async (req, res) => {
  handleK8sApiRequest(req, res, '/api/v1/persistentvolumes');
});

// Original simplified paths (for existing frontend code in kubernetes.ts, ClusterDetails.tsx)
app.post('/api/k8s/nodes', async (req, res) => {
  handleK8sApiRequest(req, res, '/api/v1/nodes');
});

app.post('/api/k8s/pods', async (req, res) => {
  handleK8sApiRequest(req, res, '/api/v1/pods');
});

app.post('/api/k8s/persistentvolumes', async (req, res) => {
  handleK8sApiRequest(req, res, '/api/v1/persistentvolumes');
});

// Function to handle Kubernetes API requests
async function handleK8sApiRequest(req, res, k8sPath) {
  try {
    const { kubeconfig } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig' });
    }
    
    console.log(`Proxying request to Kubernetes API: ${k8sPath}`);
    
    let token;
    try {
      // First check if this is an AWS EKS cluster and try to generate a fresh token
      const eksInfo = extractAwsEksInfo(kubeconfig);
      
      if (eksInfo && eksInfo.clusterName && eksInfo.region) {
        // Generate a fresh token via AWS CLI
        try {
          token = await generateAwsEksToken(eksInfo.clusterName, eksInfo.region);
          console.log('Successfully generated fresh AWS EKS token');
        } catch (eksError) {
          console.error('Failed to generate AWS EKS token, falling back to static token:', eksError.message);
          // Fall back to static token if AWS token generation fails
          token = extractK8sAuthToken(kubeconfig);
        }
      } else {
        // Not an AWS EKS cluster or can't extract EKS info, use normal token extraction
        token = extractK8sAuthToken(kubeconfig);
      }
      
      console.log('Token extracted successfully for API request');
      console.log('Token prefix:', token.substring(0, 20) + '...');
    } catch (tokenError) {
      console.error('Failed to extract token:', tokenError.message);
      return res.status(401).json({ error: `Authentication error: ${tokenError.message}` });
    }

    const clusterEndpoint = getClusterEndpoint(kubeconfig);
    const caCert = extractCaCert(kubeconfig);
    
    // Create appropriate API path based on the request
    let apiPath;
    if (k8sPath.startsWith('/')) {
      apiPath = `${clusterEndpoint}${k8sPath}`;
    } else {
      // If for some reason the path doesn't start with a slash, add it
      apiPath = `${clusterEndpoint}/${k8sPath}`;
    }
    
    console.log(`Making request to ${apiPath}`);
    
    // Make request to K8s API
    const request = https.request(apiPath, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/json'
      },
      rejectUnauthorized: false,
      ca: caCert
    }, (response) => {
      let data = '';
      response.on('data', (chunk) => {
        data += chunk;
      });
      
      response.on('end', () => {
        console.log(`API response status for ${k8sPath}: ${response.statusCode}`);
        
        if (response.statusCode >= 200 && response.statusCode < 300) {
          try {
            const jsonData = JSON.parse(data);
            res.json(jsonData);
          } catch (parseError) {
            console.error('Error parsing response JSON:', parseError);
            res.status(500).json({ error: 'Failed to parse API response' });
          }
        } else {
          console.error(`API error for ${k8sPath}:`, response.statusCode, data);
          res.status(response.statusCode).json({
            error: `Kubernetes API returned error: ${response.statusCode}`,
            details: data
          });
        }
      });
    });
    
    request.on('error', (error) => {
      console.error(`API request error for ${k8sPath}:`, error);
      res.status(500).json({
        error: `Failed to connect to Kubernetes API: ${error.message}`
      });
    });
    
    request.end();
  } catch (error) {
    console.error('Error in Kubernetes API proxy:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
}

// Legacy specific endpoint for nodes (can be removed once the generic endpoint is tested)
app.post('/api/k8s/nodes-old', async (req, res) => {
  try {
    const { kubeconfig } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig' });
    }
    
    let token;
    try {
      // First check if this is an AWS EKS cluster and try to generate a fresh token
      const eksInfo = extractAwsEksInfo(kubeconfig);
      
      if (eksInfo && eksInfo.clusterName && eksInfo.region) {
        // Generate a fresh token via AWS CLI
        try {
          token = await generateAwsEksToken(eksInfo.clusterName, eksInfo.region);
          console.log('Successfully generated fresh AWS EKS token');
        } catch (eksError) {
          console.error('Failed to generate AWS EKS token, falling back to static token:', eksError.message);
          // Fall back to static token if AWS token generation fails
          token = extractK8sAuthToken(kubeconfig);
        }
      } else {
        // Not an AWS EKS cluster or can't extract EKS info, use normal token extraction
        token = extractK8sAuthToken(kubeconfig);
      }
      
      console.log('Token extracted successfully for nodes request');
      console.log('Token prefix:', token.substring(0, 20) + '...');
    } catch (tokenError) {
      console.error('Failed to extract token:', tokenError.message);
      return res.status(401).json({ error: `Authentication error: ${tokenError.message}` });
    }

    const clusterEndpoint = getClusterEndpoint(kubeconfig);
    const caCert = extractCaCert(kubeconfig);
    
    // Create request URL
    const apiEndpoint = `${clusterEndpoint}/api/v1/nodes`;
    
    console.log(`Making request to ${apiEndpoint}`);
    
    // Make request to K8s API
    const request = https.request(apiEndpoint, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/json'
      },
      // For development - ignore certificate errors
      rejectUnauthorized: false,
      ca: caCert
    }, (response) => {
      let data = '';
      response.on('data', (chunk) => {
        data += chunk;
      });
      
      response.on('end', () => {
        console.log(`Nodes API response status: ${response.statusCode}`);
        
        if (response.statusCode >= 200 && response.statusCode < 300) {
          res.json(JSON.parse(data));
        } else {
          console.error(`Kubernetes API error: ${response.statusCode}`, data);
          res.status(response.statusCode).json({
            error: `Kubernetes API error: ${response.statusCode}`,
            message: data
          });
        }
      });
    });
    
    request.on('error', (error) => {
      console.error('Error contacting Kubernetes API:', error);
      res.status(500).json({ error: error.message });
    });
    
    request.end();
  } catch (error) {
    console.error('Error proxying to Kubernetes API:', error);
    res.status(500).json({ error: error.message });
  }
});

// Proxy Kubernetes API requests for pods
app.post('/api/k8s/pods', async (req, res) => {
  try {
    const { kubeconfig, namespace } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig' });
    }
    
    let token;
    try {
      // First check if this is an AWS EKS cluster and try to generate a fresh token
      const eksInfo = extractAwsEksInfo(kubeconfig);
      
      if (eksInfo && eksInfo.clusterName && eksInfo.region) {
        // Generate a fresh token via AWS CLI
        try {
          token = await generateAwsEksToken(eksInfo.clusterName, eksInfo.region);
          console.log('Successfully generated fresh AWS EKS token for pods request');
        } catch (eksError) {
          console.error('Failed to generate AWS EKS token, falling back to static token:', eksError.message);
          // Fall back to static token if AWS token generation fails
          token = extractK8sAuthToken(kubeconfig);
        }
      } else {
        // Not an AWS EKS cluster or can't extract EKS info, use normal token extraction
        token = extractK8sAuthToken(kubeconfig);
      }
      console.log('Token extracted successfully for pods request');
      console.log('Token prefix:', token.substring(0, 20) + '...');
    } catch (tokenError) {
      console.error('Failed to extract token:', tokenError.message);
      return res.status(401).json({ error: `Authentication error: ${tokenError.message}` });
    }
    
    const clusterEndpoint = getClusterEndpoint(kubeconfig);
    const caCert = extractCaCert(kubeconfig);
    
    // Create request URL
    const apiEndpoint = namespace 
      ? `${clusterEndpoint}/api/v1/namespaces/${namespace}/pods` 
      : `${clusterEndpoint}/api/v1/pods`;
    
    console.log(`Making pods request to ${apiEndpoint}`);
    
    // Make request to K8s API
    const request = https.request(apiEndpoint, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/json'
      },
      // For development - ignore certificate errors
      rejectUnauthorized: false,
      ca: caCert
    }, (response) => {
      let data = '';
      response.on('data', (chunk) => {
        data += chunk;
      });
      
      response.on('end', () => {
        console.log(`Pods API response status: ${response.statusCode}`);
        
        if (response.statusCode >= 200 && response.statusCode < 300) {
          res.json(JSON.parse(data));
        } else {
          console.error(`Kubernetes API error: ${response.statusCode}`, data);
          res.status(response.statusCode).json({
            error: `Kubernetes API error: ${response.statusCode}`,
            message: data
          });
        }
      });
    });
    
    request.on('error', (error) => {
      console.error('Error contacting Kubernetes API:', error);
      res.status(500).json({ error: error.message });
    });
    
    request.end();
  } catch (error) {
    console.error('Error proxying to Kubernetes API:', error);
    res.status(500).json({ error: error.message });
  }
});

// Proxy Kubernetes API request for pod YAML
app.post('/api/k8s/pod-yaml', async (req, res) => {
  try {
    const { kubeconfig, podName, namespace } = req.body;
    
    if (!kubeconfig || !podName || !namespace) {
      return res.status(400).json({ error: 'Missing required parameters: kubeconfig, podName, namespace' });
    }
    
    let token;
    try {
      // First check if this is an AWS EKS cluster and try to generate a fresh token
      const eksInfo = extractAwsEksInfo(kubeconfig);
      
      if (eksInfo && eksInfo.clusterName && eksInfo.region) {
        // Generate a fresh token via AWS CLI
        try {
          token = await generateAwsEksToken(eksInfo.clusterName, eksInfo.region);
          console.log('Successfully generated fresh AWS EKS token for pod YAML request');
        } catch (eksError) {
          console.error('Failed to generate AWS EKS token, falling back to static token:', eksError.message);
          // Fall back to static token if AWS token generation fails
          token = extractK8sAuthToken(kubeconfig);
        }
      } else {
        // Not an AWS EKS cluster or can't extract EKS info, use normal token extraction
        token = extractK8sAuthToken(kubeconfig);
      }
      console.log('Token extracted successfully for pod YAML request');
      console.log('Token prefix:', token.substring(0, 20) + '...');
    } catch (tokenError) {
      console.error('Failed to extract token for pod YAML:', tokenError.message);
      return res.status(401).json({ error: `Authentication error: ${tokenError.message}` });
    }
    
    const clusterEndpoint = getClusterEndpoint(kubeconfig);
    const caCert = extractCaCert(kubeconfig);
    
    // First, get pod details
    const podApiEndpoint = `${clusterEndpoint}/api/v1/namespaces/${namespace}/pods/${podName}`;
    
    console.log(`Making pod YAML request to ${podApiEndpoint}`);
    
    // Make request to K8s API to get pod details
    const request = https.request(podApiEndpoint, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/json'
      },
      // For development - ignore certificate errors
      rejectUnauthorized: false,
      ca: caCert
    }, (response) => {
      let data = '';
      response.on('data', (chunk) => {
        data += chunk;
      });
      
      response.on('end', () => {
        console.log(`Pod YAML API response status: ${response.statusCode}`);
        
        if (response.statusCode >= 200 && response.statusCode < 300) {
          try {
            const podData = JSON.parse(data);
            
            // Convert the data to YAML format
            const yamlOutput = yaml.dump(podData);
            
            // Return the YAML response to the client
            res.json({ yaml: yamlOutput });
          } catch (parseError) {
            console.error('Error parsing pod data:', parseError);
            res.status(500).json({
              error: 'Error parsing pod data',
              details: parseError.message
            });
          }
        } else {
          console.error(`Kubernetes API error: ${response.statusCode}`, data);
          res.status(response.statusCode).json({
            error: `Kubernetes API error: ${response.statusCode}`,
            message: data
          });
        }
      });
    });
    
    request.on('error', (error) => {
      console.error('Error fetching pod YAML:', error);
      res.status(500).json({ error: error.message });
    });
    
    request.end();
  } catch (error) {
    console.error('Error proxying pod YAML request:', error);
    res.status(500).json({ error: error.message });
  }
});

// Helper function to make Kubernetes API requests with token refresh retry for EKS
export async function makeK8sRequestWithRetry(kubeconfig, apiPath, method = 'GET') {
  return new Promise(async (resolve, reject) => {
    let attempts = 0;
    const maxAttempts = 2; // Initial attempt + 1 retry with fresh token

    const tryRequest = async (tokenToUse) => {
      attempts++;
      try {
        const clusterEndpoint = getClusterEndpoint(kubeconfig);
        const caCert = extractCaCert(kubeconfig);
        const apiUrl = `${clusterEndpoint}${apiPath}`; // Combine endpoint and path

        console.log(`Making K8s request (Attempt ${attempts}) to ${apiUrl} with token prefix: ${tokenToUse.substring(0, 20)}...`);

        const requestOptions = {
          method: method,
          headers: {
            'Authorization': `Bearer ${tokenToUse}`,
            'Accept': 'application/json'
          },
          ...(caCert && {
            ca: Buffer.from(caCert, 'base64').toString('ascii'),
            // Disable validation only for development, use rejectUnauthorized: true in production
            rejectUnauthorized: process.env.NODE_ENV !== 'production' ? false : true 
          })
        };

        // Add NODE_TLS_REJECT_UNAUTHORIZED warning suppression if needed
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
          console.warn('IMPORTANT: TLS certificate validation is disabled. Use only for development.');
        } else {
          // Ensure it's set back to default if in production
          delete process.env.NODE_TLS_REJECT_UNAUTHORIZED;
        }

        const request = https.request(apiUrl, requestOptions, (response) => {
          let data = '';
          response.on('data', (chunk) => data += chunk);
          response.on('end', async () => {
            try {
              if (response.statusCode === 200) {
                console.log(`K8s request to ${apiPath} successful (Status ${response.statusCode})`);
                resolve(JSON.parse(data));
              } else if (response.statusCode === 401 && attempts < maxAttempts) {
                console.warn(`K8s request failed with 401 (Attempt ${attempts}). Checking for EKS config to refresh token.`);
                const eksInfo = extractAwsEksInfo(kubeconfig);
                if (eksInfo && eksInfo.clusterName && eksInfo.region) {
                  console.log('EKS config found. Attempting to generate a fresh token.');
                  try {
                    const freshToken = await generateAwsEksToken(eksInfo.clusterName, eksInfo.region);
                    console.log('Successfully generated fresh AWS EKS token.');
                    // Update the environment variable potentially? Or just use for retry? Let's use just for retry.
                    // process.env.VITE_K8S_AUTH_TOKEN = freshToken; // Consider updating the env var?
                    await tryRequest(freshToken); // Retry with the fresh token
                  } catch (tokenError) {
                    console.error('Failed to generate fresh EKS token:', tokenError);
                    reject({ statusCode: 401, error: `Failed to refresh EKS token: ${tokenError.message}`, data: data });
                  }
                } else {
                  console.error('Request failed with 401, but no EKS info found to refresh token.');
                  reject({ statusCode: response.statusCode, error: `Request failed with status ${response.statusCode}`, data: data });
                }
              } else {
                console.error(`Error fetching ${apiPath}: Status code ${response.statusCode}`);
                reject({ statusCode: response.statusCode, error: `Request failed with status ${response.statusCode}`, data: data });
              }
            } catch (parseError) {
               console.error(`Error parsing K8s response for ${apiPath}:`, parseError);
               reject({ statusCode: 500, error: 'Failed to parse K8s response', data: data });
            }
          });
        });

        request.on('error', (error) => {
          console.error(`Error during K8s request to ${apiPath}:`, error);
          reject({ statusCode: 500, error: `Request failed: ${error.message}` });
        });

        request.end();

      } catch (initialError) {
        console.error(`Failed to initiate K8s request to ${apiPath}:`, initialError);
        // If token extraction itself failed before the request
         if (attempts === 1) { // Only reject on first attempt if token extraction fails
            reject({ statusCode: 500, error: `Failed to prepare request: ${initialError.message}` });
         } else {
           // If error happened during retry setup (less likely here)
           reject({ statusCode: 500, error: `Failed during retry setup: ${initialError.message}` });
         }
      }
    };

    // Start the first attempt
    try {
        const initialToken = extractK8sAuthToken(kubeconfig);
        await tryRequest(initialToken);
    } catch (tokenExtractionError) {
        console.error('Initial token extraction failed:', tokenExtractionError);
        reject({ statusCode: 500, error: `Failed to get initial token: ${tokenExtractionError.message}` });
    }
  });
}

// New endpoint to get namespaces
app.post('/api/k8s/namespaces', async (req, res) => {
  try {
    const { kubeconfig } = req.body;

    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig' });
    }

    // For mock data mode
    if (process.env.VITE_USE_MOCK_K8S_DATA === 'true') {
      console.log('Using mock data for namespaces endpoint');
      return res.json({
        items: [
          { metadata: { name: 'default' } },
          { metadata: { name: 'kube-system' } },
          { metadata: { name: 'kube-public' } },
          { metadata: { name: 'kube-node-lease' } }
        ]
      });
    }

    // Use the new helper function
    const apiPath = '/api/v1/namespaces';
    const namespacesData = await makeK8sRequestWithRetry(kubeconfig, apiPath);
    res.json(namespacesData);

  } catch (error) {
    console.error('Error in namespaces endpoint:', error);
    const statusCode = error.statusCode || 500;
    res.status(statusCode).json({ error: `Failed to fetch namespaces: ${error.error || error.message}` });
  }
});

// New endpoint to get services
app.post('/api/k8s/services', async (req, res) => {
  try {
    const { kubeconfig, namespace = '' } = req.body;

    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig' });
    }

    // For mock data mode
    if (process.env.VITE_USE_MOCK_K8S_DATA === 'true') {
      console.log('Using mock data for services endpoint');
      return res.json({
        items: [
          {
            metadata: {
              name: 'kubernetes',
              namespace: 'default'
            },
            spec: {
              type: 'ClusterIP',
              ports: [{ port: 443, protocol: 'TCP' }]
            }
          }
        ]
      });
    }

    // Use the new helper function
    const apiPath = namespace
      ? `/api/v1/namespaces/${namespace}/services`
      : '/api/v1/services';
    const servicesData = await makeK8sRequestWithRetry(kubeconfig, apiPath);
    res.json(servicesData);

  } catch (error) {
    console.error('Error in services endpoint:', error);
    const statusCode = error.statusCode || 500;
    res.status(statusCode).json({ error: `Failed to fetch services: ${error.error || error.message}` });
  }
});

// New endpoint to get kubeconfig details
app.post('/api/k8s/kubeconfig-details', async (req, res) => {
  try {
    const { kubeconfig } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig' });
    }
    
    try {
      const config = yaml.load(kubeconfig);
      
      // Extract key information from kubeconfig
      const details = {
        clusters: config.clusters?.map(cluster => ({
          name: cluster.name,
          server: cluster.cluster?.server,
          certificateAuthorityPresent: !!cluster.cluster?.['certificate-authority-data'],
        })) || [],
        
        contexts: config.contexts?.map(context => ({
          name: context.name,
          cluster: context.context?.cluster,
          user: context.context?.user,
          namespace: context.context?.namespace,
        })) || [],
        
        users: config.users?.map(user => ({
          name: user.name,
          authType: user.user?.token ? 'token' : 
                   user.user?.['client-certificate-data'] ? 'certificate' : 
                   user.user?.exec ? 'exec' : 'unknown',
          execCommand: user.user?.exec?.command,
          execArgs: user.user?.exec?.args,
        })) || [],
        
        currentContext: config['current-context'],
        apiVersion: config.apiVersion,
        kind: config.kind
      };
      
      // For AWS EKS clusters, try to extract additional information
      const awsInfo = extractAwsEksInfo(kubeconfig);
      if (awsInfo) {
        details.awsInfo = awsInfo;
      }
      
      res.json(details);
    } catch (error) {
      console.error('Error parsing kubeconfig:', error);
      res.status(400).json({ error: `Failed to parse kubeconfig: ${error.message}` });
    }
    
  } catch (error) {
    console.error('Error in kubeconfig-details endpoint:', error);
    res.status(500).json({ error: `Internal server error: ${error.message}` });
  }
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'healthy', timestamp: new Date().toISOString() });
});

// Configure Node.js to use the certificate authority data from the kubeconfig
// This is a global setting that affects all HTTPS requests
// For development only - in production, you would use proper certificate validation
process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';

// Helper function to create empty response templates for Kubernetes resources
function createEmptyK8sResourceList(kind) {
  return {
    kind: `${kind}List`,
    apiVersion: 'v1',
    metadata: {
      resourceVersion: '',
    },
    items: []
  };
}

// Add missing Kubernetes API endpoints
// Deployments endpoint
app.post('/api/k8s/deployments', async (req, res) => {
  try {
    console.log('Handling /api/k8s/deployments request');
    const { kubeconfig, namespace } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig in request body' });
    }

    // Create empty deployments response
    const emptyDeployments = createEmptyK8sResourceList('Deployment');
    
    // Return empty list for now
    res.json(emptyDeployments);
  } catch (error) {
    console.error('Error handling deployments request:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// ReplicaSets endpoint
app.post('/api/k8s/replicasets', async (req, res) => {
  try {
    console.log('Handling /api/k8s/replicasets request');
    const { kubeconfig, namespace } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig in request body' });
    }

    // Create empty replicasets response
    const emptyReplicaSets = createEmptyK8sResourceList('ReplicaSet');
    
    // Return empty list for now
    res.json(emptyReplicaSets);
  } catch (error) {
    console.error('Error handling replicasets request:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// StatefulSets endpoint
app.post('/api/k8s/statefulsets', async (req, res) => {
  try {
    console.log('Handling /api/k8s/statefulsets request');
    const { kubeconfig, namespace } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig in request body' });
    }

    // Create empty statefulsets response
    const emptyStatefulSets = createEmptyK8sResourceList('StatefulSet');
    
    // Return empty list for now
    res.json(emptyStatefulSets);
  } catch (error) {
    console.error('Error handling statefulsets request:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// DaemonSets endpoint
app.post('/api/k8s/daemonsets', async (req, res) => {
  try {
    console.log('Handling /api/k8s/daemonsets request');
    const { kubeconfig, namespace } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig in request body' });
    }

    // Create empty daemonsets response
    const emptyDaemonSets = createEmptyK8sResourceList('DaemonSet');
    
    // Return empty list for now
    res.json(emptyDaemonSets);
  } catch (error) {
    console.error('Error handling daemonsets request:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// Jobs endpoint
app.post('/api/k8s/jobs', async (req, res) => {
  try {
    console.log('Handling /api/k8s/jobs request');
    const { kubeconfig, namespace } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig in request body' });
    }

    // Create empty jobs response
    const emptyJobs = createEmptyK8sResourceList('Job');
    
    // Return empty list for now
    res.json(emptyJobs);
  } catch (error) {
    console.error('Error handling jobs request:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// CronJobs endpoint
app.post('/api/k8s/cronjobs', async (req, res) => {
  try {
    console.log('Handling /api/k8s/cronjobs request');
    const { kubeconfig, namespace } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig in request body' });
    }

    // Create empty cronjobs response
    const emptyCronJobs = createEmptyK8sResourceList('CronJob');
    
    // Return empty list for now
    res.json(emptyCronJobs);
  } catch (error) {
    console.error('Error handling cronjobs request:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// Ingresses endpoint
app.post('/api/k8s/ingresses', async (req, res) => {
  try {
    console.log('Handling /api/k8s/ingresses request');
    const { kubeconfig, namespace } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig in request body' });
    }

    // Create empty ingresses response
    const emptyIngresses = createEmptyK8sResourceList('Ingress');
    
    // Return empty list for now
    res.json(emptyIngresses);
  } catch (error) {
    console.error('Error handling ingresses request:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// ConfigMaps endpoint
app.post('/api/k8s/configmaps', async (req, res) => {
  try {
    console.log('Handling /api/k8s/configmaps request');
    const { kubeconfig, namespace } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig in request body' });
    }

    // Create empty configmaps response
    const emptyConfigMaps = createEmptyK8sResourceList('ConfigMap');
    
    // Return empty list for now
    res.json(emptyConfigMaps);
  } catch (error) {
    console.error('Error handling configmaps request:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// Secrets endpoint
app.post('/api/k8s/secrets', async (req, res) => {
  try {
    console.log('Handling /api/k8s/secrets request');
    const { kubeconfig, namespace } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig in request body' });
    }

    // Create empty secrets response
    const emptySecrets = createEmptyK8sResourceList('Secret');
    
    // Return empty list for now
    res.json(emptySecrets);
  } catch (error) {
    console.error('Error handling secrets request:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// ResourceQuotas endpoint
app.post('/api/k8s/resourcequotas', async (req, res) => {
  try {
    console.log('Handling /api/k8s/resourcequotas request');
    const { kubeconfig, namespace } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig in request body' });
    }

    // Create empty resourcequotas response
    const emptyResourceQuotas = createEmptyK8sResourceList('ResourceQuota');
    
    // Return empty list for now
    res.json(emptyResourceQuotas);
  } catch (error) {
    console.error('Error handling resourcequotas request:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// LimitRanges endpoint
app.post('/api/k8s/limitranges', async (req, res) => {
  try {
    console.log('Handling /api/k8s/limitranges request');
    const { kubeconfig, namespace } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig in request body' });
    }

    // Create empty limitranges response
    const emptyLimitRanges = createEmptyK8sResourceList('LimitRange');
    
    // Return empty list for now
    res.json(emptyLimitRanges);
  } catch (error) {
    console.error('Error handling limitranges request:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// PersistentVolumes endpoint
app.post('/api/k8s/persistentvolumes', async (req, res) => {
  try {
    console.log('Handling /api/k8s/persistentvolumes request');
    const { kubeconfig } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig in request body' });
    }

    // Create empty persistent volumes response
    const emptyPVs = createEmptyK8sResourceList('PersistentVolume');
    
    // Return empty list for now
    res.json(emptyPVs);
  } catch (error) {
    console.error('Error handling persistentvolumes request:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// PersistentVolumeClaims endpoint
app.post('/api/k8s/persistentvolumeclaims', async (req, res) => {
  try {
    console.log('Handling /api/k8s/persistentvolumeclaims request');
    const { kubeconfig, namespace } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig in request body' });
    }

    // Create empty persistent volume claims response
    const emptyPVCs = createEmptyK8sResourceList('PersistentVolumeClaim');
    
    // Return empty list for now
    res.json(emptyPVCs);
  } catch (error) {
    console.error('Error handling persistentvolumeclaims request:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// StorageClasses endpoint
app.post('/api/k8s/storageclasses', async (req, res) => {
  try {
    console.log('Handling /api/k8s/storageclasses request');
    const { kubeconfig } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig in request body' });
    }

    // Create empty storage classes response
    const emptySCs = createEmptyK8sResourceList('StorageClass');
    
    // Return empty list for now
    res.json(emptySCs);
  } catch (error) {
    console.error('Error handling storageclasses request:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// Metrics endpoint
app.post('/api/k8s/metrics', async (req, res) => {
  try {
    console.log('Handling /api/k8s/metrics request');
    const { kubeconfig } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig in request body' });
    }

    // Create sample metrics response
    const sampleMetrics = {
      cpuUsage: {
        used: '500m',
        total: '8000m',
        percent: 6.25
      },
      memoryUsage: {
        used: '2.5Gi',
        total: '32Gi',
        percent: 7.8
      },
      podUsage: {
        used: 12,
        total: 110,
        percent: 10.9
      }
    };
    
    // Return sample metrics
    res.json(sampleMetrics);
  } catch (error) {
    console.error('Error handling metrics request:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// Logs endpoint
app.post('/api/k8s/logs', async (req, res) => {
  try {
    console.log('Handling /api/k8s/logs request');
    const { kubeconfig, podName, namespace, container, tail } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig in request body' });
    }

    // Create empty logs response
    const emptyLogs = {
      items: []
    };
    
    // Return empty list for now
    res.json(emptyLogs);
  } catch (error) {
    console.error('Error handling logs request:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// New endpoint to generate YAML for selected components
app.post('/api/k8s/generate-yaml', async (req, res) => {
  try {
    console.log('Handling /api/k8s/generate-yaml request');
    const { kubeconfig, resources } = req.body;
    
    if (!kubeconfig) {
      return res.status(400).json({ error: 'Missing kubeconfig in request body' });
    }
    
    if (!resources || !Array.isArray(resources) || resources.length === 0) {
      return res.status(400).json({ error: 'Missing or invalid resources array in request body' });
    }
    
    console.log(`Generating YAML for ${resources.length} resources`);
    
    try {
      // Get cluster endpoint and token
      const clusterEndpoint = getClusterEndpoint(kubeconfig);
      const token = extractK8sAuthToken(kubeconfig);
      const caCert = extractCaCert(kubeconfig);
      
      // Process each resource to get its YAML
      const yamlDocs = [];
      
      for (const resource of resources) {
        const { kind, namespace, name } = resource;
        
        // Determine the correct API path for this resource type
        const apiPath = determineResourceApiPath(kind, namespace, name);
        
        if (!apiPath) {
          console.warn(`Unsupported resource kind: ${kind}`);
          continue;
        }
        
        try {
          // For development/demo, generate placeholder YAML
          // In production, this would make a real API call to the K8s cluster
          const resourceData = await makeK8sRequestWithRetry(kubeconfig, apiPath);
          
          // Remove cluster-specific fields
          if (resourceData.metadata) {
            delete resourceData.metadata.resourceVersion;
            delete resourceData.metadata.uid;
            delete resourceData.metadata.selfLink;
            delete resourceData.metadata.creationTimestamp;
            delete resourceData.metadata.generation;
            delete resourceData.status;
          }
          
          // Convert to YAML
          const resourceYaml = yaml.dump(resourceData);
          yamlDocs.push(resourceYaml);
          
        } catch (resourceError) {
          console.error(`Error fetching resource ${kind}/${namespace}/${name}:`, resourceError);
          
          // For demo/development, generate placeholder YAML
          const placeholderYaml = `# Resource: ${kind}/${namespace}/${name}
apiVersion: ${getApiVersionForKind(kind)}
kind: ${kind}
metadata:
  name: ${name}
  namespace: ${namespace}
# This is a placeholder. The actual resource definition would be here.
`;
          yamlDocs.push(placeholderYaml);
        }
      }
      
      // Combine all YAML documents
      const combinedYaml = yamlDocs.join('---\n\n');
      
      res.json({ yaml: combinedYaml });
      
    } catch (error) {
      console.error('Error generating YAML:', error);
      res.status(500).json({ error: `Failed to generate YAML: ${error.message}` });
    }
  } catch (error) {
    console.error('Error in generate-yaml endpoint:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// Helper function to determine the API path for a given resource
function determineResourceApiPath(kind, namespace, name) {
  // Map resource kinds to their API paths
  const apiPathMap = {
    Deployment: namespace ? 
      `/apis/apps/v1/namespaces/${namespace}/deployments/${name}` : 
      `/apis/apps/v1/deployments/${name}`,
    StatefulSet: namespace ? 
      `/apis/apps/v1/namespaces/${namespace}/statefulsets/${name}` : 
      `/apis/apps/v1/statefulsets/${name}`,
    DaemonSet: namespace ? 
      `/apis/apps/v1/namespaces/${namespace}/daemonsets/${name}` : 
      `/apis/apps/v1/daemonsets/${name}`,
    Service: namespace ? 
      `/api/v1/namespaces/${namespace}/services/${name}` : 
      `/api/v1/services/${name}`,
    ConfigMap: namespace ? 
      `/api/v1/namespaces/${namespace}/configmaps/${name}` : 
      `/api/v1/configmaps/${name}`,
    Secret: namespace ? 
      `/api/v1/namespaces/${namespace}/secrets/${name}` : 
      `/api/v1/secrets/${name}`,
    Ingress: namespace ? 
      `/apis/networking.k8s.io/v1/namespaces/${namespace}/ingresses/${name}` : 
      `/apis/networking.k8s.io/v1/ingresses/${name}`,
    PersistentVolumeClaim: namespace ? 
      `/api/v1/namespaces/${namespace}/persistentvolumeclaims/${name}` : 
      `/api/v1/persistentvolumeclaims/${name}`,
    Pod: namespace ? 
      `/api/v1/namespaces/${namespace}/pods/${name}` : 
      `/api/v1/pods/${name}`
  };
  
  return apiPathMap[kind] || null;
}

// Helper function to get the API version for a kind
function getApiVersionForKind(kind) {
  const apiVersionMap = {
    Deployment: 'apps/v1',
    StatefulSet: 'apps/v1',
    DaemonSet: 'apps/v1',
    Service: 'v1',
    ConfigMap: 'v1',
    Secret: 'v1',
    Ingress: 'networking.k8s.io/v1',
    PersistentVolumeClaim: 'v1',
    Pod: 'v1'
  };
  
  return apiVersionMap[kind] || 'v1';
}

// Migration endpoint to transfer resources between clusters
app.post('/api/k8s/migrate', async (req, res) => {
  try {
    console.log('Handling /api/k8s/migrate request');
    const { sourceKubeconfig, targetKubeconfig, resources, options } = req.body;
    
    if (!sourceKubeconfig || !targetKubeconfig) {
      return res.status(400).json({ 
        error: 'Missing source or target kubeconfig in request body' 
      });
    }
    
    if (!resources || !Array.isArray(resources) || resources.length === 0) {
      return res.status(400).json({ 
        error: 'Missing or invalid resources array in request body' 
      });
    }
    
    console.log(`Starting migration of ${resources.length} resources`);
    
    // Initialize migration status object for tracking progress
    const migrationId = Date.now().toString();
    const migrationStatus = {
      id: migrationId,
      startTime: new Date(),
      status: 'in-progress',
      resourcesTotal: resources.length,
      resourcesMigrated: 0,
      resourcesFailed: 0,
      completedResources: [],
      failedResources: [],
      currentStep: 'initializing',
      logs: []
    };
    
    // Add first log entry
    migrationStatus.logs.push({
      timestamp: new Date(),
      level: 'info',
      message: `Starting migration of ${resources.length} resources`
    });
    
    // Create a response immediately with the migration ID
    res.json({ 
      migrationId,
      message: 'Migration started successfully',
      status: migrationStatus
    });
    
    // Continue processing the migration asynchronously
    processMigration(sourceKubeconfig, targetKubeconfig, resources, options, migrationStatus)
      .catch(error => {
        console.error(`Migration ${migrationId} failed:`, error);
        migrationStatus.status = 'failed';
        migrationStatus.error = error.message;
        migrationStatus.logs.push({
          timestamp: new Date(),
          level: 'error',
          message: `Migration failed: ${error.message}`
        });
      });
      
  } catch (error) {
    console.error('Error in migration endpoint:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// Migration status endpoint
app.get('/api/k8s/migration/:id/status', (req, res) => {
  const { id } = req.params;
  
  // In a real implementation, we would store migration statuses in a database
  // For now, we'll just return a mock status
  // This would need to be replaced with actual status retrieval
  
  res.json({
    id,
    status: 'completed', // or 'in-progress', 'failed'
    progress: 100,
    resourcesTotal: 5,
    resourcesMigrated: 5,
    resourcesFailed: 0,
    completedResources: [
      { kind: 'Deployment', name: 'nginx', namespace: 'default' },
      { kind: 'Service', name: 'nginx', namespace: 'default' }
    ],
    failedResources: [],
    logs: [
      { timestamp: new Date(), level: 'info', message: 'Migration completed successfully' }
    ]
  });
});

// Asynchronous function to process the actual migration
async function processMigration(migrationId, sourceKubeconfig, targetKubeconfig, resources, options) {
  // Get the job from activeJobs
  const migrationStatus = activeJobs.get(migrationId);
  if (!migrationStatus) {
    throw new Error(`Migration job ${migrationId} not found`);
  }
  
  // Define temporary files for kubeconfig
  const sourceTempFile = path.join(os.tmpdir(), `source-kubeconfig-${migrationId}.yaml`);
  const targetTempFile = path.join(os.tmpdir(), `target-kubeconfig-${migrationId}.yaml`);
  
  try {
    // Step 1: Extract resources from source cluster
    migrationStatus.currentStep = 'Extracting resources';
    console.log(`Migration ${migrationId}: Starting extraction of ${resources.length} resources`);
    
    // Write kubeconfigs to temporary files
    fs.writeFileSync(sourceTempFile, sourceKubeconfig);
    fs.writeFileSync(targetTempFile, targetKubeconfig);
    
    // Process each resource
    for (let i = 0; i < resources.length; i++) {
      const resource = resources[i];
      try {
        console.log(`Migration ${migrationId}: Processing ${resource.kind} ${resource.name}`);
        
        // Step 1: Extract resource from source cluster
        migrationStatus.currentStep = `Extracting ${resource.kind} ${resource.name}`;
        const extractCmd = `kubectl --kubeconfig=${sourceTempFile} get ${resource.kind.toLowerCase()} ${resource.name} -n ${resource.namespace || 'default'} -o yaml`;
        const { stdout: resourceYaml } = await execPromise(extractCmd);
        
        // Step 2: Transform the resource for the target cluster
        migrationStatus.currentStep = `Transforming ${resource.kind} ${resource.name}`;
        
        // Parse the YAML
        const resourceObj = yaml.load(resourceYaml);
        
        // Remove cluster-specific fields
        if (resourceObj.metadata) {
          delete resourceObj.metadata.uid;
          delete resourceObj.metadata.resourceVersion;
          delete resourceObj.metadata.creationTimestamp;
          delete resourceObj.metadata.generation;
          delete resourceObj.metadata.managedFields;
          delete resourceObj.metadata.selfLink;
          delete resourceObj.metadata.ownerReferences;
        }
        
        // Remove status completely
        delete resourceObj.status;
        
        // Handle node affinity and volumes based on options
        if (resourceObj.spec) {
          if (!options.preserveNodeAffinity && resourceObj.spec.affinity) {
            delete resourceObj.spec.affinity.nodeAffinity;
          }
          
          if (!options.migrateVolumes && resourceObj.spec.volumes) {
            resourceObj.spec.volumes = resourceObj.spec.volumes.filter(vol => !vol.persistentVolumeClaim);
          }
        }
        
        // Convert back to YAML
        const transformedYaml = yaml.dump(resourceObj);
        
        // Write to temp file
        const tempYamlPath = path.join(os.tmpdir(), `resource-${migrationId}-${i}.yaml`);
        fs.writeFileSync(tempYamlPath, transformedYaml);
        
        try {
          // Step 3: Apply to target cluster
          migrationStatus.currentStep = `Applying ${resource.kind} ${resource.name} to target`;
          const targetNamespace = options.targetNamespace || resource.namespace || 'default';
          
          // Create namespace first if needed
          if (resource.kind !== 'Namespace' && targetNamespace !== 'default') {
            try {
              await execPromise(`kubectl --kubeconfig=${targetTempFile} create namespace ${targetNamespace} --dry-run=client -o yaml | kubectl --kubeconfig=${targetTempFile} apply -f -`);
            } catch (nsError) {
              console.log(`Note: Namespace ${targetNamespace} may already exist: ${nsError.message}`);
            }
          }
          
          // Apply the resource
          const applyCmd = `kubectl --kubeconfig=${targetTempFile} apply -f ${tempYamlPath} -n ${targetNamespace}`;
          await execPromise(applyCmd);
          
          // Step 4: Delete from source if requested
          if (options.deleteFromSource) {
            migrationStatus.currentStep = `Deleting ${resource.kind} ${resource.name} from source`;
            const deleteCmd = `kubectl --kubeconfig=${sourceTempFile} delete ${resource.kind.toLowerCase()} ${resource.name} -n ${resource.namespace || 'default'}`;
            await execPromise(deleteCmd);
          }
          
          // Update progress
          migrationStatus.resourcesMigrated++;
          
        } finally {
          // Clean up temp resource file
          try {
            if (fs.existsSync(tempYamlPath)) {
              fs.unlinkSync(tempYamlPath);
            }
          } catch (cleanupError) {
            console.warn(`Failed to clean up temp file ${tempYamlPath}:`, cleanupError);
          }
        }
        
      } catch (error) {
        console.error(`Error processing ${resource.kind} ${resource.name}:`, error);
        migrationStatus.error = `Failed to migrate ${resource.kind} ${resource.name}: ${error.message}`;
        migrationStatus.status = 'failed';
        activeJobs.set(migrationId, migrationStatus);
        throw error;
      }
    }
    
    console.log(`Migration ${migrationId}: All resources processed successfully`);
    
    // Update status
    migrationStatus.status = 'completed';
    migrationStatus.currentStep = 'Migration completed';
    activeJobs.set(migrationId, migrationStatus);
  } catch (error) {
    console.error(`Migration ${migrationId} failed:`, error);
    migrationStatus.status = 'failed';
    migrationStatus.error = error.message || 'Unknown error occurred during migration';
    activeJobs.set(migrationId, migrationStatus);
    throw error;
  } finally {
    // Clean up kubeconfig temp files
    try {
      if (fs.existsSync(sourceTempFile)) {
        fs.unlinkSync(sourceTempFile);
      }
      if (fs.existsSync(targetTempFile)) {
        fs.unlinkSync(targetTempFile);
async function verifyResourcesInTargetCluster(kubeconfig, resources, migrationStatus) {
  for (const resource of migrationStatus.completedResources) {
    try {
      const { kind, namespace, name } = resource;
      
      migrationStatus.logs.push({
        timestamp: new Date(),
        level: 'info',
        message: `Verifying ${kind}/${namespace}/${name} in target cluster`
      });
      
      // Determine the API path for this resource
      const apiPath = determineResourceApiPath(kind, namespace, name);
      
      if (!apiPath) {
        throw new Error(`Unsupported resource kind for verification: ${kind}`);
      }
      
      // Get the resource from the target cluster
      const resourceData = await makeK8sRequestWithRetry(kubeconfig, apiPath);
      
      // Verify the resource is in the expected state
      // For simplicity, we just check it exists, but in a real implementation
      // we would check specific fields match the expected values
      
      migrationStatus.logs.push({
        timestamp: new Date(),
        level: 'info',
        message: `Successfully verified ${kind}/${namespace}/${name} in target cluster`
      });
      
    } catch (error) {
      migrationStatus.logs.push({
        timestamp: new Date(),
        level: 'error',
        message: `Failed to verify ${resource.kind}/${resource.namespace}/${resource.name}: ${error.message}`
      });
    }
  }
}

// Helper function to determine the API path for resource creation
function determineResourceApiPathForCreation(kind, namespace) {
  // Map resource kinds to their API paths for creation (POST)
  const apiPathMap = {
    Deployment: namespace ? 
      `/apis/apps/v1/namespaces/${namespace}/deployments` : 
      `/apis/apps/v1/deployments`,
    StatefulSet: namespace ? 
      `/apis/apps/v1/namespaces/${namespace}/statefulsets` : 
      `/apis/apps/v1/statefulsets`,
    DaemonSet: namespace ? 
      `/apis/apps/v1/namespaces/${namespace}/daemonsets` : 
      `/apis/apps/v1/daemonsets`,
    Service: namespace ? 
      `/api/v1/namespaces/${namespace}/services` : 
      `/api/v1/services`,
    ConfigMap: namespace ? 
      `/api/v1/namespaces/${namespace}/configmaps` : 
      `/api/v1/configmaps`,
    Secret: namespace ? 
      `/api/v1/namespaces/${namespace}/secrets` : 
      `/api/v1/secrets`,
    Ingress: namespace ? 
      `/apis/networking.k8s.io/v1/namespaces/${namespace}/ingresses` : 
      `/apis/networking.k8s.io/v1/ingresses`,
    PersistentVolumeClaim: namespace ? 
      `/api/v1/namespaces/${namespace}/persistentvolumeclaims` : 
      `/api/v1/persistentvolumeclaims`,
    Pod: namespace ? 
      `/api/v1/namespaces/${namespace}/pods` : 
      `/api/v1/pods`,
    Namespace: `/api/v1/namespaces`
  };
  
  return apiPathMap[kind] || null;
}

// Attach tenant-specific endpoints
attachTenantEndpoints(app, makeK8sRequestWithRetry);

// Migration API endpoints for real migration between EKS clusters
const activeJobs = new Map(); // Track active migrations

// Start a new migration
app.post('/api/migrations/start', async (req, res) => {
  try {
    const { migrationId, sourceKubeconfig, targetKubeconfig, resources, options } = req.body;
    
    console.log(`Starting migration ${migrationId} with ${resources.length} resources`);
    
    // Check if all required parameters are provided
    if (!migrationId || !sourceKubeconfig || !targetKubeconfig || !resources || !Array.isArray(resources)) {
      return res.status(400).json({ error: 'Missing required parameters' });
    }
    
    // Store migration info for status tracking
    activeJobs.set(migrationId, {
      id: migrationId,
      status: 'running',
      currentStep: 'initializing',
      resourcesMigrated: 0,
      resourcesTotal: resources.length,
      startTime: Date.now(),
      resources: resources,
      sourceKubeconfig,
      targetKubeconfig,
      options,
      logs: [], // Add logs array to store migration progress updates
      error: null
    });
    
    // Start the migration asynchronously
    processMigration(migrationId, sourceKubeconfig, targetKubeconfig, resources, options)
      .then(() => {
        console.log(`Migration ${migrationId} completed successfully`);
      })
      .catch(error => {
        console.error(`Migration ${migrationId} failed:`, error);
        const job = activeJobs.get(migrationId);
        if (job) {
          job.status = 'failed';
          job.error = error.message;
        }
      });
    
    // Return immediately with the migration ID
    return res.json({ migrationId });
  } catch (error) {
    console.error('Error starting migration:', error);
    return res.status(500).json({ error: error.message });
  }
});

// Get migration status
app.get('/api/migrations/:id/status', (req, res) => {
  const { id } = req.params;
  const job = activeJobs.get(id);
  
  if (!job) {
    return res.status(404).json({ error: 'Migration not found' });
  }
  
  return res.json({
    id: job.id,
    status: job.status,
    currentStep: job.currentStep,
    resourcesMigrated: job.resourcesMigrated,
    resourcesTotal: job.resourcesTotal,
    error: job.error
  });
});

// Cancel migration
app.post('/api/migrations/:id/cancel', (req, res) => {
  const { id } = req.params;
  const job = activeJobs.get(id);
  
  if (!job) {
    return res.status(404).json({ error: 'Migration not found' });
  }
  
  if (job.status === 'completed') {
    return res.status(400).json({ error: 'Migration already completed' });
  }
  
  job.status = 'failed';
  job.error = 'Migration cancelled by user';
  
  return res.json({ success: true });
});

// Perform actual Kubernetes resource migration
async function performMigration(migrationId, sourceKubeconfig, targetKubeconfig, resources, options) {
  const job = activeJobs.get(migrationId);
  if (!job) return;
  
  try {
    // Step 1: Export resources from source cluster
    job.currentStep = 'extracting';
    console.log(`Migration ${migrationId}: Extracting resources from source cluster`);
    
    const resourceManifests = [];
    
    // Extract each resource one by one
    for (let i = 0; i < resources.length; i++) {
      const resource = resources[i];
      console.log(`Extracting ${resource.kind} ${resource.name} from namespace ${resource.namespace || 'cluster-level'}`);
      
      try {
        // Execute kubectl get command to export the resource manifest
        const manifest = await extractResourceFromCluster(sourceKubeconfig, resource);
        if (manifest) {
          resourceManifests.push({
            resource,
            manifest
          });
        }
        
        // Update progress
        job.resourcesMigrated = i + 1;
      } catch (error) {
        console.error(`Error extracting ${resource.kind} ${resource.name}:`, error);
        // Continue with other resources even if one fails
      }
    }
    
    // Step 2: Transform resource manifests for target cluster
    job.currentStep = 'transforming';
    console.log(`Migration ${migrationId}: Transforming resource manifests`);
    
    const transformedManifests = [];
    for (const { resource, manifest } of resourceManifests) {
      // Transform manifest for target cluster
      const transformed = await transformManifestForTarget(manifest, options.targetNamespace);
      transformedManifests.push({
        resource,
        manifest: transformed
      });
    }
    
    // Step 3: Apply resources to target cluster
    job.currentStep = 'applying';
    console.log(`Migration ${migrationId}: Applying resources to target cluster`);
    
    let appliedCount = 0;
    for (const { resource, manifest } of transformedManifests) {
      try {
        // Apply manifest to target cluster
        await applyManifestToCluster(targetKubeconfig, manifest);
        appliedCount++;
      } catch (error) {
        console.error(`Error applying ${resource.kind} ${resource.name}:`, error);
      }
    }
    
    // Step 4: Migrate persistent volumes if requested
    if (options.migrateVolumes) {
      job.currentStep = 'migrating_volumes';
      console.log(`Migration ${migrationId}: Migrating persistent volumes`);
      
      // Implementation for PV migration would go here
      // This would involve more specialized logic for volume data transfer
    }
    
    // Step 5: Verify resources in target cluster
    job.currentStep = 'verifying';
    console.log(`Migration ${migrationId}: Verifying migration`);
    
    // Optional: Delete resources from source if everything succeeded
    // This step is commented out for safety but can be enabled
    /*
    if (appliedCount === transformedManifests.length) {
      job.currentStep = 'cleaning_source';
      console.log(`Migration ${migrationId}: Cleaning up source cluster resources`);
      
      for (const { resource } of resourceManifests) {
        try {
          await deleteResourceFromCluster(sourceKubeconfig, resource);
        } catch (error) {
          console.error(`Error deleting ${resource.kind} ${resource.name} from source:`, error);
        }
      }
    }
    */
    
    // Mark migration as complete
    job.status = 'completed';
    job.currentStep = 'completed';
    console.log(`Migration ${migrationId} completed successfully`);
  } catch (error) {
    console.error(`Migration ${migrationId} failed:`, error);
    job.status = 'failed';
    job.error = error.message;
  }
}

// Helper function to extract a resource from a Kubernetes cluster
async function extractResourceFromCluster(kubeconfig, resource) {
  const { kind, name, namespace } = resource;
  
  try {
    // Write kubeconfig to temp file
    const kubeconfigPath = `/tmp/kubeconfig-${Date.now()}.yaml`;
    fs.writeFileSync(kubeconfigPath, kubeconfig);
    
    // Prepare kubectl command
    let command = '';
    if (namespace) {
      command = `kubectl --kubeconfig=${kubeconfigPath} -n ${namespace} get ${kind.toLowerCase()} ${name} -o yaml`;
    } else {
      command = `kubectl --kubeconfig=${kubeconfigPath} get ${kind.toLowerCase()} ${name} -o yaml`;
    }
    
    // Execute command
    const { stdout, stderr } = await execPromise(command);
    
    // Clean up temp file
    fs.unlinkSync(kubeconfigPath);
    
    if (stderr && !stdout) {
      throw new Error(stderr);
    }
    
    return stdout;
  } catch (error) {
    console.error(`Error extracting resource ${kind} ${name}:`, error);
    throw error;
  }
}

// Helper function to transform resource manifest for target cluster
async function transformManifestForTarget(manifest, targetNamespace) {
  try {
    // Parse YAML manifest
    const resourceObj = yaml.load(manifest);
    
    // Remove fields that shouldn't be copied
    delete resourceObj.metadata.uid;
    delete resourceObj.metadata.resourceVersion;
    delete resourceObj.metadata.creationTimestamp;
    delete resourceObj.metadata.generation;
    delete resourceObj.metadata.managedFields;
    delete resourceObj.status;
    
    // Set target namespace if specified and the resource is namespace-scoped
    if (targetNamespace && resourceObj.metadata.namespace) {
      resourceObj.metadata.namespace = targetNamespace;
    }
    
    // Add migration annotation
    resourceObj.metadata.annotations = resourceObj.metadata.annotations || {};
    resourceObj.metadata.annotations['migration.kubernetes.io/migrated'] = 'true';
    resourceObj.metadata.annotations['migration.kubernetes.io/timestamp'] = new Date().toISOString();
    
    // Convert back to YAML
    return yaml.dump(resourceObj);
  } catch (error) {
    console.error('Error transforming manifest:', error);
    throw error;
  }
}

// Helper function to apply manifest to target cluster
async function applyManifestToCluster(kubeconfig, manifest) {
  try {
    // Write kubeconfig and manifest to temp files
    const kubeconfigPath = `/tmp/kubeconfig-${Date.now()}.yaml`;
    const manifestPath = `/tmp/manifest-${Date.now()}.yaml`;
    
    fs.writeFileSync(kubeconfigPath, kubeconfig);
    fs.writeFileSync(manifestPath, manifest);
    
    // Apply using kubectl
    const command = `kubectl --kubeconfig=${kubeconfigPath} apply -f ${manifestPath}`;
    const { stdout, stderr } = await execPromise(command);
    
    // Clean up temp files
    fs.unlinkSync(kubeconfigPath);
    fs.unlinkSync(manifestPath);
    
    if (stderr && !stdout) {
      throw new Error(stderr);
    }
    
    return stdout;
  } catch (error) {
    console.error('Error applying manifest:', error);
    throw error;
  }
}

// Helper function to delete a resource from a cluster
async function deleteResourceFromCluster(kubeconfig, resource) {
  const { kind, name, namespace } = resource;
  
  try {
    // Write kubeconfig to temp file
    const kubeconfigPath = `/tmp/kubeconfig-${Date.now()}.yaml`;
    fs.writeFileSync(kubeconfigPath, kubeconfig);
    
    // Prepare kubectl command
    let command = '';
    if (namespace) {
      command = `kubectl --kubeconfig=${kubeconfigPath} -n ${namespace} delete ${kind.toLowerCase()} ${name}`;
    } else {
      command = `kubectl --kubeconfig=${kubeconfigPath} delete ${kind.toLowerCase()} ${name}`;
    }
    
    // Execute command
    const { stdout, stderr } = await execPromise(command);
    
    // Clean up temp file
    fs.unlinkSync(kubeconfigPath);
    
    if (stderr && !stdout) {
      throw new Error(stderr);
    }
    
    return stdout;
  } catch (error) {
    console.error(`Error deleting resource ${kind} ${name}:`, error);
    throw error;
  }
}

// Using the execPromise that was already defined at the top of the file

// Start the server
app.listen(port, () => {
  console.log(`Proxy server running on port ${port}`);
  console.log('- POST /api/k8s/generate-yaml - Generate migration YAML');
  console.log('- POST /api/k8s/migrate - Migrate resources between clusters');
  console.log('- GET /api/k8s/migration/:id/status - Check migration status');
  console.log('- POST /api/k8s/tenant/* - Tenant-specific endpoints');
  
  // Log real migration endpoints
  console.log('- POST /api/migrations/start - Start a new real migration');
  console.log('- GET /api/migrations/:id/status - Check real migration status');
  console.log('- POST /api/migrations/:id/cancel - Cancel a real migration');
});
